
[简体中文](https://mivik.moe/2025/solution/tpctf-2025/#ipvm)

This challenge is based on [IPFS](https://ipfs.tech), a decentralized file storage protocol. IPFS essentially splits a piece of data into many blocks, each uniquely identified by its hash value. The entire data is also identified by a hash value (the hash of all its sub-blocks concatenated and hashed again, see Merkle Tree), called CID. These blocks are then distributed across a P2P network. Ideally, you only need the CID of a data or file to recursively download all its sub-blocks from the network. Sounds cool! But in reality, P2P is far from being ideal; moreover, IPFS has various design flaws, see [How IPFS is broken](https://fiatjaf.com/d5031e5b.html). There're still a batch of people using IPFS, so yeah, it's up to you to decide.

Back to this challenge. This challenge provides a WASM runtime platform based on IPFS. You can:

- `build`: Upload a folder containing `wat` / `wasm` files (yes, IPFS supports folders), and the server will optimize and compile it, sign it, and return the compiled package CID.
- `run`: Upload a package CID, and the server will verify the signature and run it.

That's it, really simple. Where can the vulnerability even be?

We know that the running process of wasm generally involves AOT compilation followed by local execution. Here `build` and `run` basically reproduce this process, which could lead to RCE because the output of `build` is essentially native code. If we can control the input to `run`, we can do whatever we want. However, the signature verification is quite annoying. If the output is not generated by a normal `build`, it won't pass the signature verification. Wasmtime, the runtime environment, is known for its security, making it difficult to exploit a 0day RCE from wasm. What should we do then?

If you are carefully enough, you can spot an inconsistency in the way the server reads files from the folder. The first method is `ipfs_read`, which directly calls `ipfs cat <path>` to print the file content. Here, `path` can be either the CID itself (of course, this requires that the CID corresponds to a file rather than a folder) or a sub-file path of the CID (e.g., `CID/config.json`). The second method is to create a temporary folder and use `ipfs get <CID>` to download all files from the CID into this temporary folder.

This inconsistency turns out to be the key to the vulnerability. After some digging, we know that IPFS uses [DAG-PB](https://ipld.io/docs/codecs/known/dag-pb/) to store directories. The protobuf definition is as follows:

```protobuf
message PBLink {
  // binary CID (with no multibase prefix) of the target object
  optional bytes Hash = 1;

  // UTF-8 string name
  optional string Name = 2;

  // cumulative size of target object
  optional uint64 Tsize = 3;
}

message PBNode {
  // refs to other objects
  repeated PBLink Links = 2;

  // opaque user data
  optional bytes Data = 1;
}
```

An idea emerges: what if we have multiple `PBLink` with the same name in a `PBNode` (corresponding to multiple files with the same name in a folder)? It turns out that `ipfs cat` will return the content of the first file, while `ipfs get` will write all files sequentially, resulting in the last file's content being the final output. This inconsistency allows us to maliciously append a `main.cwasm` to the package generated by `build`. During signature verification, `ipfs cat` will work fine, but when we download and execute it using `ipfs get`, it will execute our malicious `main.cwasm`. This is how we achieve RCE.

As for constructing malicious payload `main.cwasm`, I patched a compiled `main.cwasm` using IDA, injecting a segment of shellcode into the function execution part.

> P.S. Use `protoc dag.proto --python_out .` to compile protobuf
